# Macros

Contains various macros used across the project mostly for generating boilerplate code.

## data_integration_macro

Binance imposes an interesting integration challenge due to its decision to separate
spot, coin margined and USD margined futures into three different platforms. Fundamentally,
all three platforms and corresponding testnets provide mostly the same API and only differ in
the actual URL of the service. Therefore,
the [binance_core_data_integration](../queng_integration/data/binance_core_data_integration) implements the required
traits for the entire Binance integration using the platform URL as a parameter. Because each integration would have to
re-implement those traits over the core integration, the data_integration_macro actually generates that implementation
for any struct that provides an existing field named integration of type `ImsDataIntegration`.

**Important:**

The field named integration must be of type `ImsDataIntegration` and not `ImsDataIntegrationImpl`
and must be named integration for the macro to work because the macro uses the field name to generate the trait
implementations.

All 3 binance platforms and the corresponding testnets can be implemented in about 30 lines of code using just the
macro.
See a concrete example below:

```rust
#[derive(Default, ImsDataIntegrationImpl)]
pub struct ImsBinanceSpotDataIntegration {
    integration: ImsBinanceDataIntegration,
}

impl ImsBinanceSpotDataIntegration {
    pub fn new() -> Self {
        Self {
            integration: ImsBinanceDataIntegration::new(SPOT_API_BASE_URL, SPOT_API_WSS_URL),
        }
    }

    pub fn testnet() -> Self {
        Self {
            integration: ImsBinanceDataIntegration::new(
                SPOT_TESTNET_API_BASE_URL,
                SPOT_TESTNET_API_WSS_URL,
            ),
        }
    }
}
```

All methods required by the ImsDataIntegration trait will be generated by the macro.